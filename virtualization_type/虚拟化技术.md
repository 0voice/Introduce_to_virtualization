# 软件模拟虚拟化、全虚拟化、半虚拟化、硬件辅助虚拟化和容器

目前虚拟化技术有软件模拟、全虚拟化（使用二进制翻译）、半虚拟化（操作系统辅助）、硬件辅助虚拟化和容器虚拟化这几种。

## 1. 软件模拟
软件模拟是通过软件完全模拟cpu、芯片组、磁盘、网卡等计算机硬件：

![image](https://user-images.githubusercontent.com/87458342/135199189-f8ca013b-c21b-40e4-9cbb-1b16c6a11806.png)

因为是软件模拟，所以理论上可以模拟任何硬件，但是非常低效，一般只用于研究测试的场景，典型的有QEMU。

## 2. 全虚拟化
x86平台指令集分为4个特权模式：Ring0 、Ring1、Ring2、Ring3、OS工作在Ring0级别，应用软件工作在Ring3级别，驱动程序工作在Ring1和Ring2。

![image](https://user-images.githubusercontent.com/87458342/135199939-f6a6a6aa-fad4-4419-93b2-fc4eab4d90ed.png)

如何将虚拟机越级的指令使用进行隔离，1998年VMware首次找到了解决办法，通过虚拟化引擎，捕获虚拟机的指令，并进行处理，即全虚拟化方案。
在全虚拟化的情况下，VMM工作在Ring 0 ，Guest OS工作在Ring 1 ，应用程序工作在Ring 3，可是这时候Guest OS是不知道自己工作在虚拟机里的，认为自己还是工作在Ring 0 ，所以它还是按照Ring 0级别产特权生指令，Guest OS产生的每一条指令都会被VMM截取，并翻译成宿主机平台的指令，然后交给实际的物理平台执行，由于每一条指令都需要这么翻译一下，所以这种虚拟化性能比较差。

![image](https://user-images.githubusercontent.com/87458342/135200115-d03732b9-d26e-4aa6-928f-e852a5891a43.png)

## 3. 半虚拟化**
半虚拟化是对Guest OS做相应修改，以便和VMM协同运作。在硬件辅助虚拟化兴起之前，半虚拟化性能胜过全虚拟化。在半虚拟化情况下，Guest OS知道自己并不是直接运行在硬件资源上，而是运行在虚拟化环境里，工作在非Ring 0，那么它原先在物理机上执行的一些特权指令，就会修改成其他方式（超级调用），这种方式是可以和VMM约定好的，半虚拟化不需要VMM层进行二进制翻译，所以性能较好，但是实现比较麻烦（要修改OS内核代码），典型的半虚拟化技术有xen。

![image](https://user-images.githubusercontent.com/87458342/135200207-0556db7e-dce4-49b5-a14f-6104a0f9e28f.png)

## 4. 硬件辅助虚拟化**
2005年，Intel推出了硬件辅助虚拟化方案，对CPU指令进行改造，即VT-x，VT-x提供了两种操作模式：VMX root operation和VMX non-root operation，VMM运行在 VMX root operation，虚拟机运行在VMX non-root operation。在绝大多数情况下，客户机在此模式下运行与原生系统在非虚拟化环境中运行性能一样，不需要像全虚拟化那样每条指令都要先翻译再执行；在少数必要的时候，某些客户机指令的运行才需要被VMM截获并做相应处理。这种方案因为是基于硬件的，所以效率非常高。

![image](https://user-images.githubusercontent.com/87458342/135200286-d21ccfcb-9b08-4ce7-bb22-80534d399738.png)

现在不仅CPU指令有硬件虚拟化方案，I/O通信也有硬件解决方案，称为VT-d；网络通信的称为VT-c。

## 5. 容器虚拟化
容器虚拟化是基于CGroups、Namespace等技术将进程进行隔离，每个进程就像一台独立的虚拟机，拥有自己被隔离出来的资源，也有自己的根目录、独立的进程编号、被隔离的内存空间。基于容器的虚拟化可以实现在单一内核上运行多个实例。目前热门的容器虚拟化技术Docker，Docker可以将一个开发环境进行打包，很方便在另一个系统上运行起来。



原文作者：   -光光-
